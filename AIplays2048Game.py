# -*- coding: utf-8 -*-
"""AIplays2048game.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/118B1pFcyN8O9n3FLab6xoeqT3AvfXh14
"""

import numpy as np
import random

class Game2048:
    def __init__(self):
        self.board = np.zeros((4, 4), dtype=int)
        self.score = 0
        self._add_new_tile()
        self._add_new_tile()

    def _add_new_tile(self):
        empty_positions = list(zip(*np.where(self.board == 0)))
        if empty_positions:
            row, col = random.choice(empty_positions)
            self.board[row][col] = 2 if random.random() < 0.9 else 4

    def _merge(self, row):
        non_zero_row = row[row != 0]
        merged_row = []
        skip = False
        for j in range(len(non_zero_row)):
            if skip:
                skip = False
                continue
            if j + 1 < len(non_zero_row) and non_zero_row[j] == non_zero_row[j + 1]:
                merged_row.append(2 * non_zero_row[j])
                self.score += 2 * non_zero_row[j]
                skip = True
            else:
                merged_row.append(non_zero_row[j])
        return np.array(merged_row + [0] * (len(row) - len(merged_row)))

    def move_left(self):
        new_board = np.zeros((4, 4), dtype=int)
        for i in range(4):
            new_board[i] = self._merge(self.board[i])
        if not np.array_equal(self.board, new_board):
            self.board = new_board
            self._add_new_tile()

    def move_right(self):
        self.board = np.fliplr(self.board)
        self.move_left()
        self.board = np.fliplr(self.board)

    def move_up(self):
        self.board = np.transpose(self.board)
        self.move_left()
        self.board = np.transpose(self.board)

    def move_down(self):
        self.board = np.transpose(self.board)
        self.move_right()
        self.board = np.transpose(self.board)

    def get_possible_moves(self):
        moves = []
        for move, direction in zip([self.move_left, self.move_right, self.move_up, self.move_down], ['left', 'right', 'up', 'down']):
            temp_board = self.board.copy()
            move()
            if not np.array_equal(self.board, temp_board):
                moves.append(direction)
            self.board = temp_board
        return moves

    def is_game_over(self):
        return len(self.get_possible_moves()) == 0

    def display(self):
        print(f"Score: {self.score}")
        print(self.board)


class AI2048:
    def __init__(self, game):
        self.game = game

    def heuristic(self):
        empty_tiles = np.sum(self.game.board == 0)
        max_tile = np.max(self.game.board)
        return empty_tiles + np.log2(max_tile)

    def get_best_move(self):
        best_move = None
        best_heuristic = -1
        for move in self.game.get_possible_moves():
            temp_game = Game2048()
            temp_game.board = self.game.board.copy()
            temp_game.score = self.game.score
            getattr(temp_game, f"move_{move}")()
            move_heuristic = self.heuristic()
            if move_heuristic > best_heuristic:
                best_heuristic = move_heuristic
                best_move = move
        return best_move

    def play(self):
        while not self.game.is_game_over():
            best_move = self.get_best_move()
            if best_move:
                getattr(self.game, f"move_{best_move}")()
                self.game.display()
            else:
                break
        print("Game Over!")


if __name__ == "__main__":
    game = Game2048()
    ai = AI2048(game)
    ai.play()